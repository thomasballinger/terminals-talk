<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">

<title>Terminal Whispering</title>

<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
<meta name="author" content="Hakim El Hattab">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="css/reveal.css">
<link rel="stylesheet" href="css/theme/black.css" id="theme">

<!-- Code syntax highlighting -->
<link rel="stylesheet" href="lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

  <!-- Any section element inside of this container is displayed as a slide -->
  <div class="slides">
    <section>
      <h1>Terminal Whispering</h1>
      <p>Do more than print text with your terminal</p>
      <p>
      <small><a href="http://ballingt.com">Thomas Ballinger</a> | <a href="http://twitter.com/ballingt">@ballingt</a> | <a href="mailto:me@ballingt.com">me@ballingt.com</a> | <a href="https://www.recurse.com">tom@recurse.com</a></small>
      </p>
      <aside class="notes">
        Hello! I'd like to talk about how to use our terminals - we use them every day, we might as well learn how. This is a talk not about shell scripting, how to use the command line - but about the actual terminal.

      </aside>
    </section>
    <section>
    <h2>How we use terminals</h2>
      <aside class="notes">
        Many of us use terminals daily - typically in a call and response manner:
      </aside>
    </section>
    <section data-background="normal.gif">
      <aside class="notes">
        The Python interactive interpreter works like this, Bash works like this
      </aside>
    </section>
    <!-- TODO spread examples throughout talk-->

    <section data-background="top.gif"></section>
      <aside class="notes">
        But here another program you may be familiar with - it doesn't do call and response.
        It takes over the whole screen.
      </aside>
    <!--
    <section data-background="tig.gif">
      <aside class="notes">
        More immersive, kind of like vim or emacs
      </aside>
    </section>
    -->
    <section data-background="pudb.gif">
      <aside class="notes">
        At least 3 secret techniques we want to learn about, but there are a lot encompassed in that last one.
      </aside>
    </section>
    <!--
    <section data-background="bpython-curtsies-demo-large.gif">
      <aside class="notes">
        Wouldn't it be cool to unlock this power? To understand the
        language we use to speak to terminals, it'll be useful to look
        at an abbreviated, more-useful-than-correct history lessson.

        I want to unlock this power for you by giving you an overview of how terminals work and what to Google for.
      </aside>
    </section>
    -->
  </section>
    <section>
      <h2>What are terminals?</h2>
      <aside class="notes">
        What are terminals?
        Well, we're usually talking about terminal emulators.
      </aside>
    </section>
    <!--
    <section data-background="wordcloud.png">
      <aside class="notes">
        ...not any of these things
    <h2>Image credits</h2>
    <ul>
      <li>Wordcloud credit: https://www.jasondaviescom/wordcloud</li>
    </ul>
      </aside>

    </section>
    -->
    <section data-background="single-terminal.png">
      <aside class="notes">
        <p>
        When I say "terminal", I'm usually talking about a terminal emulator.
        </p>

        <p>
        You can see the little mac GUI stuff in this picture - 
        that's sort of important, we're going to talk about terminals as they exist
        in unix systems - I don't know how much of this is translatable to the Windows console.
        </p>

        <p>
        Windows users: open up a PUTTY terminal on a server for this or use Cygwin
        </p>

        <p>
        So what do I mean by terminal?
        I mean the interface a command line program has to the user - where
        an interactive command line program assumes it's output is going
        to be displayed, and where it's expected to get input from.

        This means I'll be lumping in things the kernal does in tandem with the terminal emulator,
        because this is about the interface presented to the application.

        What is it that we're emulating?

      </aside>
    </section>
    <section data-background="terminals.png">
      <aside class="notes">
        video terminals!
      </aside>
    </section>
    <section data-background="DEC_VT100_terminal.jpg">
      <aside class="notes">
        I usually think we're emulating these things:
        video terminals. Applications would be written
        anticipating that the human user would be sitting in front
        of one of these. But video terminals were emulating something
        else originally...
      </aside>
    </section>
    <section data-background="teletypes.png">
      <aside class="notes">
        Teleprinters or teletypewriters, or one of the brands...

        Things like this have been around for over a hundred years!

        Check out a youtube video of this stuff, they're
        mechanical marvels!
        These had been being used to send telegraphs for a long time
        (great 1940 video about how they work: https://www.youtube.com/watch?v=HcMHam54EOI)
      </aside>
    </section>
    <section data-background="teletypeadimage.png">
      <aside class="notes">
        I'd like to read you a bit from a teletype ad, this one is from 1957.
        <p>
        A Teletype Printer is a communications device -- with a keyboard similar to a typewriter -- that enables you to send and receive printed messages. With it, written word can be sent instantaneously by wire...within the office or plant...or clear across the country; to a single destination...or to any number at the same time.
        </p>

        <p>
        In today's business world, in fact, Teletype equipment is often more than a communications instrument. It is a basic element in production control sytems...its ability to transmit and reproduce text and punched tape is harnessed to office automation...it provides a "conveyor system" for channeling complex raw data to a computing center thousands of miles away.
        </p>

        <p>
        Whether leased through your telephone company or other communication companies -- or purchased outright from us -- the versatile line of Teletype equipment can be tailored to almost any conceivable demand. For further information, contact your telephone company or other communications company, or send for our free booklet, "The ABC's of Teletype Equipment," Teletype Corporation, Dept. F7, 4100 Fullerton Ave., Chicago 39, Illinois.
        </p>

        <p>
        1957 Golden Anniversary Year
        </p>
        The way teletypes work lays the foundation for the way
        terminal emulators still work today.

        (originally 1907)
      </aside>
    </section>

   <!--   <section>
        <pre class="ascii-diagram">
   application--------maybe copper?
     Λ                       |
     |                       |
   signal over metal wire    |
     |                       |
   teletypewriter<-----------+
     Λ      |
     |     ink
     |      |
     |      V
     |    paper
     |
  fingers pressing keys
        </pre>
        <aside class="notes">
          The way teletypes work lays the foundation for the way
          terminal emulators still work today.
        </aside>
      </section>
      -->
      <section>
        <pre class="ascii-diagram">
<span style="color:grey">   application--------maybe copper?
     Λ                       |
     |                       |
   signal over metal wire    |
     |                       |</span>
    typewriter<span style="color:grey"><--------------+</span>
     Λ      |
     |     ink
     |      |
     |      V
     |    paper
     |
  fingers pressing keys
        </pre>
        <aside class="notes">
          A user types at an electronic typewriter which both puts ink to
          paper immediately...
        </aside>
      </section>
      <section>
        <pre class="ascii-diagram">
   application<span style="color:grey">--------maybe copper?</span>
     Λ                       <span style="color:grey">|</span>
     |                       <span style="color:grey">|</span>
   signal over metal wire    <span style="color:grey">|</span>
     |                       <span style="color:grey">|</span>
   teletypewriter<span style="color:grey"><-----------+</span>
     Λ      |
     |     ink
     |      |
     |      V
     |    paper
     |
  fingers pressing keys
        </pre>
        <aside class="notes">
          and also sends some kind of signal down a wire.
          This could be only 5 bits for telegraph stuff
          
          
          , then ANSI made it 7 -
          who knows if you need a whole byte or not? Write a device driver
          that deals with whatever telegraph stuff was already in place
        </aside>
      </section>
      <section>
        <pre class="ascii-diagram">
   application--------maybe copper?
     Λ                       |
     |                       |
   signal over metal wire    |
     |                       |
   teletypewriter<-----------+
     Λ      |
     |     ink
     |      |
     |      V
     |    paper
     |
  fingers pressing keys
        </pre>
        <aside class="notes">
          The application sends back data that gets printed by the teletype.

          Once again, very interesting on YouTube videos! I'll link at the end.

          Next, let's look at the modernized version of our diagram...
        </aside>
      </section>
      <section>
        <pre class="ascii-diagram">
   application-------fwrite(bytes)
     Λ                       |
     |                       |
   fread() returns bytes     |
     |                       |
   terminal<-----------------+
     Λ   |   
     |   +--GUI stuff--+
     |                 |
     |                 |
  keypresses           V
     |              screen
  keyboard
        </pre>
        <aside class="notes">
          "terminal" here means our terminal emulator.
          `read` and `write` are system calls - we call them
          on special files like standard in and out.

          The application makes both of these calls.
        </aside>
      </section>
      <section>
        <pre class="ascii-diagram">
   application------print()--+
     Λ                       |
     |                       |
   input()                   |
     |                       |
   terminal<-----------------+
<span style=color:grey>     Λ   |   
     |   +--GUI stuff--+
     |                 |
     |                 |
  keypresses           V
     |              screen
  keyboard</span>
        </pre>
        <aside class="notes">
          Or as we call them in python, input and print.

          This is a simplified diagram - there's probably some stuff between the application and the signals.
          If it's so simplified, why do we need this intermediate step? Because keypresses also cause things
          to be displayed, and messages that are sent might result in other things than text being displayed.

          We'll look at input in a moment, but first let's look at...
        </aside>
      </section>
      <section>
        <p>What bytes can we write and what happens?</p>
        <pre class="ascii-diagram">
   application-------write(bytes)
<span style="color:gray">     Λ</span>                       |
<span style="color:gray">     |</span>                       |
<span style="color:gray">   read() returns bytes</span>      |
<span style="color:gray">     |</span>                       |
   terminal<-----------------+
<span style="color:gray">     Λ</span>   |   
<span style="color:gray">     |</span>   +--GUI stuff--+
<span style="color:gray">     |</span>                 |
<span style="color:gray">  keypresses</span>           V
<span style="color:gray">     |</span>              screen
<span style="color:gray">  keyboard</span>
        </pre>
      </section>
      <section>
        <h2>What bytes can we send?</h2>
        <ul>
          <li> ASCII bytes
          <ul class="fragment">
            <li> <code>sys.stdout.buffer.write(b'some bytes')</code> </li>
            <li class="fragment"> control characters (<code>[chr(x) for x in range(32)]</code> e.g. <code>'\a\n\r\v\b\f\t'</code>) </li>
          </ul>
          </li>
        </ul>
        <aside class="notes">
          ASCII is a mapping of signals to meanings, when the signals getting sent on those metal wires
          were sort of standardized in the 60's.
        </aside>
      </section>
      <section data-background="ascii.png">
        <aside class="notes">
          ASCII is a mapping of signals to meanings, when the signals getting sent on those metal wires
          were sort of standardized in the 60's.

          Even though you only need 5 bits to get all the letters, now we'll splurge and use 7 bits(!)
          Once you start using 8-bit bytes to store a character each, we have an extra one - but ASCII was before this.
        </aside>
      </section>
      <section data-background="ascii-normal.png">
        <aside class="notes">
          First we have literals - what you send is what will appear on screen, or in your telegraph message.
        </aside>
      </section>
      <section data-background="ascii-control.png">
        <aside class="notes">
        Control characters let us do special things... (demo!)

        * python session first - but it's confusing to see
          the returns from the interactive Python session

        * write on a socket
          * literals
          * newlines
          * carriage return
          * alert
          * linefeed, backspace 
        </aside>
      </section>
      <section data-background="wget.gif">
        <aside class="notes">
          We've unlocked the secret of progress bars!
        </aside>
      </section>
      <section>
        <pre class="ascii-diagram"><code>import time, sys

def report_progress(ratio, width=50):
    filled = '=' * int(ratio * width)
    rest = '-' * (width - int(ratio*width))
    sys.stderr.write('\r|'+filled+rest+'|')
    sys.stderr.flush()

for i in range(101):
    report_progress(i/100.0, 50)
    time.sleep(.01)</code></pre>
      <aside class="notes">
        Notice: flush, writing strings instead of bytes
        You might notice that we're not writing to the buffer anymore, and we're not writing bytes
      </aside>
      </section>
      <section>
        <h2>What bytes can we send?</h2>
        <ul>
          <li> ASCII bytes
          <ul>
            <li> <code>sys.stdout.buffer.write(b'some bytes')</code> </li>
            <li> control characters (<code>[chr(x) for x in range(32)]</code> e.g. <code>'\a\n\r\v\b\f\t'</code>) </li>
          </ul>
          <li class="fragment">terminal probably using an encoding such that several bytes to make a character:
          <ul>
            <li class="fragment"> <code>sys.stdout.buffer.write(b'\xc3\xb1')</code> </li>
            <li class="fragment"> <code>sys.stdout.write(u'ñ')</code> (via <code>.encoding</code>) </li>
          </ul></li>
        </ul>
        <aside class="notes">
          In Python 3, our sys.stdout file objects have encodings which Python
          chooses based on an environmental variable called TERM so we can write
          unicode strings instead of bytes.

          <p>Everything so far makes sense on a typewriter.</p>
        </aside>
      </section>
      <section data-background="terminals.png">
        <aside class="notes">
          Now we're getting to the things that don't make sense with typewriters.
        </aside>
      </section>
      <section>
        <h2>What bytes can we send?</h2>
        <ul>
          <li> ASCII bytes
          <ul>
            <li> <code>sys.stdout.buffer.write(b'some bytes')</code> </li>
            <li> control characters (<code>[chr(x) for x in range(32)]</code> or <code>'\a\n\v\b\f\t'</code>) </li>
          </ul>
          <li> several bytes may encode a single character:
          <ul>
            <li> <code>sys.stdout.buffer.write(b'\xc3\xb1')</code> </li>
            <li> <code>sys.stdout.write(u'ñ')</code> (via <code>.encoding</code>) </li>
          </ul></li>
          <li class="fragment"> ANSI escape sequences (<code>'\x1b[31m'</code>) </li>
        </ul>
        <aside class="notes">
          Let's try this!

        </aside>
      </section>
      <section>
        <h2>ANSI escape sequences</h2>
        <table>
          <thead>
            <tr>
              <th>Sequence</th>
              <th>Meaning</th>
            </tr>
          </thead>
          <tbody>
          <tr>
            <td><code>\x1b[23A</code></td>
            <td>move cursor 23 rows up</td>
          </tr>
          <tr>
            <td><code>\x1b[2J</code></td>
            <td>clear entire screen</td>
          </tr>
          <tr>
            <td><code>\x1b[ ?25l</code></td>
            <td>hide the cursor</td>
          </tr>
          <tr>
            <td><code>\x1b[1m</code></td>
            <td>start writing in bold</td>
          </tr>
          <tr>
            <td><code>\x1b[31m</code></td>
            <td>start writing in red</td>
          </tr>
          </tbody>
        </table>

        <p>See <a href="http://en.wikipedia.org/wiki/ANSI_escape_code">Wikipedia entry on ANSI escape sequences</a> for more.</p>

        <aside class="notes">
          VT52 allowed cursor placement. In widespread use by the 80s.
          The VT100 was a big one. Applications would send these things to the terminal,
          so you wanted them to work.

          <p>Move cursor: draw windows!</p>
          <p>Show color: This implies our terminals are a little smarter - they have state!
          The terminal is put into "red" mode, and everything after that is red until it stops being red. There was state in the typewriters, but it was just "how far to the right is the cursor."</p>
        </aside>
      </section>
      <section data-background="jquast.gif">
        <aside class="notes">
          Imagine it's 1984, maybe you're 13 or maybe you're 50. You're excited to use software
          or log into bbs systems that do cool things with your video terminal, but they aren't
          compatible! Terminal hardware might have had a switch on it to choose which
          other terminal to emulate. Need an terminal compatibility layer - a jquery analogue
          to smooth over terminal differences.
        </aside>
      </section>
      <section>
        <h4>Compatibility Concerns</h4>
        <ul>
          <li class="fragment">termcap, terminfo</li>
          <li class="fragment">curses</li>
          <li class="fragment"><code>tput</code></li>
          <li class="fragment"><code>infocmp</code></li>
        </ul>
        <aside class="notes">
          Terminfo is what we use for this - it's a database of terminals, and it examines the terminal's $TERM value. In the shell you'd use tput...

          BUT the ANSI escape sequences are mostly honored, but that's like being optimistic and using cool new JavaScript features even though they won't work on
          all browsers. And there are other commands not in the ASCII spec that are like using new ecma script stuff. For browsers, there's a thing called jquery
          which acts as a compatibility layer between web application code and browsers. 

        </aside>
      </section>
      <section>
        <pre class="larger"><code class="bash">
echo "Input please"
tput cuu1
tput cuu1
tput el
read akey
tput clear
        </code></pre>
        <small>code sample from http://aplawrence.com/Basics/tput_stty.html</small>
      </section>
      <section>
        <ul>
          <li>Blessings - Erik Rose - see "Designing Poetic APIs" from PyCon 2014</li>
        </ul>
        <pre style="font-size:.7em;"><code>from blessings import Terminal

t = Terminal()

print t.bold('Hi there!')
print t.bold_red_on_bright_green('It hurts my eyes!')

with t.location(0, t.height - 1):
    print 'This is at the bottom.'
        </code></pre>
        <aside class="notes">
        BUT I wouldn't use ncurses (import curses) in the Python stdlib either. Good as a compatibility layer, bad as an api.
        Erik Rose gave a great talk last year called "designing poetic apis" in which he uses his Blessings library as an example.

        There are at least two reasons to use jquery: you like the abstractions it gives you, and compatibility.
        In my experience, the compatibility is less important because the ASCII standard mostly took hold.
        But it's still nicer than hardcoding, and it's definitely. Now that you know these are just bytes you're
        still responsible for writing to the terminal, you're prepared to using Blessings!
        </aside>
      </section>
      <section>
        Let's solve the fullscreen mystery with Blessings
        <aside class="notes">
        <code><pre class="larger">from blessings import Terminal
t = Terminal()

print t.enter_fullscreen()
raw_input()
print t.exit_fullscreen()
</pre></code>
        </aside>
      </section>
      <section>
        <h4>Secrets unlocked by writing bytes to the terminal</h4>
        <ul>
          <li>Colored and styled text (bold, underline, blink...)</li>
          <li>Moving the cursor anywhere</li>
          <li>Alternate screen</li>
          <li>Hide cursor</li>
          <li>And much more (scroll regions, save/restore cursor position; man tput for more)</li>
        </ul>
      <aside class="notes">
        Bytes you're going to write to the terminal that aren't displayed, but instead change the way the terminal works.
      </aside>
      </section>
      <section>
        <p>What happens when the user types at the keyboard?</p>
        <pre class="ascii-diagram">
   application<span style="color:gray">-------write(bytes)</span>
     Λ<span style="color:gray">                       |</span>
     |<span style="color:gray">                       |</span>
   read() returns bytes<span style="color:gray">      |</span>
     |<span style="color:gray">                       |</span>
   terminal<span style="color:gray"><-----------------+</span>
     Λ   |   
     |   +--GUI stuff--+
     |                 |
  keypresses           V
     |              screen
  keyboard
        </pre>
      </section>
      <section>
        <p>What happens when the user types at the keyboard?</p>
        <ul>
          <li class="fragment">line discipline</li>
          <ul>
            <li class="fragment">data not available to application until the user hits return</li>
            <li class="fragment">backspace, delete word, reprint line, delete line</li>
            <li class="fragment">(try cat to see this behavior)</li>
          </ul>
          <li class="fragment">other terminal settings</li>
          <ul>
            <li class="fragment">echoing back characters</li>
          </ul>
        </ul>
        <aside class="notes">
          Terminal (or something on the wire between the terminal
          and the the application) doesn't give the bytes until
          the user hits enter.

          line editing discipline - before the application gets
          the bytes, you can use delete! And delete word!

        </aside>
      </section>
    <section>
        <pre class="ascii-diagram">
           application--------maybe copper?
             Λ                       |
             |                       |
           signal over metal wire    |
             |                       |
             |                       |
           teletypewriter<-----------+
             Λ      |
             |     ink
             |      |
             |      V
             |    paper
             |
          fingers pressing keys
        </pre>
        <aside class="notes">
          Echoing back characters - the terminal is doing this,
          just like a typewriter! But it doesn't have to.
          Modified diagram! We have knobs on the terminal
          emulator, and we adjust them with 
        </aside>
    </section>
      <section>
        <pre class="ascii-diagram">
      +----application<span style="color:gray">-------write(bytes)</span>
      |      Λ<span style="color:gray">                       |</span>
     get     |<span style="color:gray">                       |</span>
      &    read() returns bytes<span style="color:gray">      |</span>
     set     |<span style="color:gray">                       |</span>
      |      |<span style="color:gray">                       |</span>
      +---⚒terminal<span style="color:gray"><-----------------+</span>
             Λ   |   
             |   +--GUI stuff--+
             |                 |
          keypresses           V
             |              screen
             |
          keyboard
            </pre>
        <aside class="notes">
          There are knobs and dials on your terminal!

          We change this stuff with ioctrl, cbreak, raw, etc

          class of system calls for messings with this stuff

        </aside>
      </section>
      <section>
        <p>Relevant man pages</p>
        <ul>
          <li> raw </li>
          <li> termios </li>
          <li> ioctl </li>
          <li> fcntl </li>
          <li> stty </li>
          <li> isatty </li>
        </ul>
        <aside class="notes">
          We change this stuff with ioctrl, cbreak, raw, etc

          class of system calls for messings with this stuff

          I'll show a quick example that your eyes are welcome to glaze over for - because afterwards
          I'll tell you to use a library for it.

          More important is knowing you can change these things.
        </aside>
      </section>
      <section>
        Turning off echo, using stty
        <pre class="larger"><code>
      $ stty -echo
      $ echo "echo is turned off"
      $ stty echo
        </code></pre>
      </section>
      <section>
        Turning off echo in Python
        <pre class="larger"> <code class="python">
      >>> import getpass
      >>> getpass.getpass()
      Password:
      'secret'
        </code> </pre>
      </section>
      <section>
        Turning off echo in Python
        <pre style="font-size:.7em;"> <code>def getpass(prompt="Password: "):
    import termios, sys
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    new = termios.tcgetattr(fd)
    new[3] = new[3] & ~termios.ECHO          # lflags
    try:
        termios.tcsetattr(fd, termios.TCSADRAIN, new)
        passwd = raw_input(prompt)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return passwd
        </code></pre>
        from https://docs.python.org/2/library/termios.html
        <aside class="notes">
          Important parts about this:


          Don't worry too much about this - the gist is that we're checking the knobs and setting the knobs.

          The finally here is really important - so a context manager might be nice!
        </aside>
      </section>
      <section>
        <pre><code>
import sys, termios

class NoEcho:
    def __init__(self, in_stream):
        self.fd = in_stream.fileno()

    def __enter__(self):
        self.orig = termios.tcgetattr(self.fd)
        new = termios.tcgetattr(self.fd)
        new[3] = new[3] & ~termios.ECHO
        termios.tcsetattr(fd, termios.TCSADRAIN, new)

    def __exit__(self, exc_type, exc_value, traceback):
        termios.tcsetattr(self.fd), termios.TCSADRAIN, self.orig)
        </code></pre>
      </section>
      <section>
        <pre class="larger"><code class="Python">
with NoEcho(sys.stdin):
    h = sys.stdin.readline()
    print(h)

        </code></pre>
        <aside class="notes">
        This is an excellent fit for a context manger, because this is state external to our
        Python program - if we crash, we don't want the terminal to be unsuable by the user.

        (tip: if it ever is, try `reset`. Twice.)
        </aside>
      </section>
      <section>
        <h4>Secret techniques made possible with these dials</h4>
        <ul>
          <li>turn off echo</li>
          <li>send keys immediately</li>
          <li>current terminal size</li>
          <li>nonblocking input</li>
          <li><code>os.isatty(sys.stdout.fileno())</code></li>
        </ul>
        <aside class="notes">
          <p>
          Some of these are bucketed up in two collections of dial settings: raw, cbreak
          </p>

          <p>
          You can do these yourself, I recommend context managers like we saw. Or use a library.
          </p>

          <p>
          cbreak and raw - bundles of these modes you'll want to use.
          </p>

          <p>
          Blessings can get terminal size, and once Blessed is merged will be able to do more of these.
          </p>

          <p>
          Nonblocking is different, it's fcntl - it's a file descriptor thing. But also relevant!
          </p>
        </aside>
      </section>
      <!--TODO           <li>mapping received bytes to keys</li> -->
      <!--TODO: What's annoying about curses? Requiring alternate screen!-->
      <section>
        <p>What happens when the user types at the keyboard</p>
        <ul>
          <li>buffering, line editing discipline</li>
          <li><ul>
            <li>data not passed to application until the user hits return</li>
            <li>backspace, delete word, reprint line, delete line - not much else</li>
            <li>to see this, try cat (it doesn't use readline)</li>
          </ul></li>
          <li> echoing back characters</li>
          <li class="fragment">mapping bytes to keys (try cat!)</li>
        </ul>
      </section>
      <section>
        <h2>Example bytes/key mappings</h2>
        <p>with my particular setup</p>
        <table>
          <thead>
            <tr>
              <th>Bytes read</th>
              <th>Key presses</th>
            </tr>
          </thead>
          <tbody>
          <tr>
            <td><code>b'a'</code></td>
            <td>a</td>
          </tr>
          <tr>
            <td><code>b'\x1b[23~'</code></td>
            <td>F11</td>
          </tr>
          <tr>
            <td><code>b'\x1b[Z'</code></td>
            <td>Shift-Tab</td>
          </tr>
          <tr>
            <td><code>b'\x1b[1;10B'</code></td>
            <td>Meta-Shift-Down</td>
          </tr>
          <tr>
            <td><code>b'\x1b[1~'</code></td>
            <td>Home</td>
          </tr>
          </tbody>
        </table>
      </section>
      <section>
        <p>What happens when the user types at the keyboard</p>
        <ul>
          <li>buffering, line editing discipline</li>
          <li><ul>
            <li>data not passed to application until the user hits return</li>
            <li>backspace, delete word, reprint line, delete line - not much else</li>
            <li>to see this, try cat (it doesn't use readline)</li>
          </ul></li>
          <li>echoing back characters</li>
          <li>mapping bytes to keys</li>
          <li class="fragment">bytes sent without being typed (cursor query)</li>
        </ul>
        <aside class="notes">
          Finally for terminal input, not all the bytes you read come from the user!

          You should try this one:
        </aside>
      </section>
      <section>
        <pre class="ascii-diagram">
        <code>>>> print("\x1b[6n")</code>
      <span style="color:gray">+----</span>application-------write(bytes)
      <span style="color:gray">|</span>      Λ                       |
     <span style="color:gray">get</span>     |                       |
      <span style="color:gray">&</span>    read() returns bytes      |
     <span style="color:gray">set</span>     |                       |
      <span style="color:gray">|</span>      |                       |
      <span style="color:gray">+---⚒</span>terminal<-----------------+
             <span style="color:gray">Λ</span>   |   
             <span style="color:gray">|</span>   +--GUI stuff--+
             <span style="color:gray">|</span>                 |
          <span style="color:gray">keypresses</span>           V
             <span style="color:gray">|</span>              screen
          <span style="color:gray">keyboard</span>
            </pre>
        <aside class="notes">
        Particularly interesting because writing bytes doesn't do anything
        to the display, we just get some informative bytes back the next time
        we call read!

        Important to do this in unbuffered mode, otherwise they'll just show
        up on the terminal line as though the user typed them.

        Try it!
        </aside>

      </section>
      <section>
        <pre class="larger"> <code>>>> print("\x1b[6n")
        </code> </pre>
      </section>
      <section>
        <pre class="larger"> <code>>>> print("\x1b[6n")
>>> 1R </code> </pre>
      </section>
      <section>
        <pre class="larger"> <code>>>> print("\x1b[6n")
>>> ESC[3;1R </code> </pre>
        <aside class="notes">
          This doesn't make sense without being in unbuffered mode
        </aside>
      </section>
      <section>
        <h2>Signals</h2>
      </section>
      <section>
        <p>How can the terminal notify the application?</p>
        <pre class="ascii-diagram">
      +----</span>application<span style="color:gray">-------write(bytes)</span>
      |<span style="color:gray">      Λ</span>    ⚡<span style="color:gray">                 |</span>
     get<span style="color:gray">     |</span>     ⚡<span style="color:gray">                |</span>
      &<span style="color:gray">    read()</span>   ⚡signals!<span style="color:gray">       |</span>
     set<span style="color:gray">     |</span>     ⚡<span style="color:gray">                |</span>
      |<span style="color:gray">      |</span>    ⚡<span style="color:gray">                 |</span>
      +---⚒</span>terminal<span style="color:gray"><-----------------+</span>
             <span style="color:gray">Λ   |</span>   
             <span style="color:gray">|   +--GUI stuff--+</span>
             <span style="color:gray">|                 |</span>
          <span style="color:gray">keypresses           V</span>
             <span style="color:gray">|              screen</span>
          <span style="color:gray">keyboard</span>
            </pre>
        <aside class="notes">
          The terminal can push things: window changes, suspend, etc.
          The behavior of these is set with our knobs.
        </aside>
      </section>
      <section>
        <p>Unix signals triggered from the terminal</p>
        <ul>
          <li class="fragment">SIGINT</li>
          <li class="fragment">SIGTSTP</li>
          <li class="fragment">SIGWINCH</li>
          <li class="fragment">tons of others, see <a href="http://www.linusakesson.net/programming/tty/">The TTY demystified</a></li>
        </ul>
        <aside class="notes">
          ctrl-c, suspend, sigwinch

          For a given terminal, you can customize when which signals are sent. Cbreak will make some keystrokes trigger signals, raw won't.

          These interrupt reads!

          PEP 475 - retry system calls failing with EINTR, but now this works differently

          This is the difference between cbreak and raw
        </aside>
      </section>
      <section>
        <h2>cooked, raw and cbreak</h2>
        <aside class="notes">
          Cbreak and raw are combinations of settings that are generally useful. Both turn off echo, unbuffer your input. This is how you should get the settings you want.
        </aside>
      </section>
      <section>
        <h2>Fancy terminal tricks in practice</h2>
        <aside class="notes">
          You should now understand *how* the terminal works, but that doesn't mean you need to code this up yourself.

          Now before I wrap up I want to give you a brief overview of tools available for doing cool terminal stuff.
        </aside>
      </section>
      <section>
        <h2>Blessings - Erik Rose</h2>
        <pre style="font-size:.7em;"><code>from blessings import Terminal
t = Terminal()

print t.bold('Hi there!')
print t.bold_red_on_bright_green('It hurts my eyes!')

with t.location(0, t.height - 1):
    print('This is at the bottom.')</code></pre>
        <aside class="notes">
          You're prepared to use Blessings because you know that it provides strings that you're going to need to write to the terminal.

          Erik Rose shoutout!

          Blessings frees you from the curses assumption that you want a fullscreen app,
          but python prompt toolkit does better for this.

          x84, Blessed (soon included in blessings) - Jeff Quast
          There will soon be input key handling, width calculations, 
        </aside>
      </section>
      <section>
        <h2>Blessed - Jeff Quast</h2>
        <pre style="font-size:.7em;"><code>from blessed import Terminal
t = Terminal()

print term.center(term.bold('X'))
with t.cbreak():
  print(sys.stdin.read(1))
  val = t.inkey(timeout=5)
  if val:
    print(val)</code></pre>
      </section>
      <section>
        <h2>Urwid</h2>
        <img src="./urwidexample.png">
        <aside class="notes">
          Urwid for big GUIs - Java-like gui stuff

          Check out pudb, mitmproxy, a version of bpython

          If you're using the full screen mode

          Review fullscreen mode! vim, emacs, tmux vs something that doesn't take over the full screen
          Curses is often used this way
        </aside>
      </section>
      <section data-background="pudb.gif"></section>
      <section>
        <h2>Click, Clint</h2>
        <aside class="notes">
          Libraries for command line utilities

          Still provide colored strings, getting a single character, detect whether stdout is a terminal like Blessings
        </aside>
      </section>
      <section>
        <h2>readline</h2>
        <aside class="notes">
          If you want to do things yourself, great - otherwise there's readline.
        </aside>
      </section>
      <section>
        <h2>Curtsies</h2>
        <aside class="notes">
          More of a framework, less composable

          Once you understand the problem, you want somethign less handholdy and more flexible

          layout engine
          Unique features: (more) composable colored strings, diffing renderer, grids of terminal-width characters
        </aside>
      </section>
      <section data-background="./bpython-curtsies-demo-large.gif"></section>
      <section>
        <h2>Python Prompt Toolkit</h2>
        <aside class="notes">
          Used for some cool tools, colors - maybe wait for the user to press a key

          *NOT* fullscreen, lets you do cool things in a command line utility-like script
        </aside>
      </section>
      <section data-background="ptpython.gif"></section>
      <section>
        <h2>pty</h2>
        <aside class="notes">
          this is how terminal emulators work!
        </aside>
      </section>
      <section data-background="./track.gif"></section>
      <section>
        <h2>pexpect</h2>
        <h3>Thomas Kluyver and Jeff Quast<h3>
        <aside class="notes">
          Python version of expect, for ru
        </aside>
      </section>
      <section>
        <h3>termcast - Jesse Luehrs</h3>
        <pre class="larger"><code>
        $ telnet termcast.org
        </code></pre>
        <ul>
          <li>https://github.com/doy/python-termcast-server</li>
          <li>https://github.com/doy/python-termcast-client</li>
        </ul>
        <aside class="notes">
          Because terminal output is just bytes, we can beam these bytes around!
        </aside>
      </section>
    <section data-background="asciinema.png"></section>
    <section><h2>using terminal formatting for test failures</h2>
      <a href="https://asciinema.org/a/5nfajhkz8u766piepw2rt53f9">pretty test failures</a>
      <a href="https://travis-ci.org/bpython/bpython/jobs/58290808">on travis</a>
    </section>
    <section data-background="./prettytests.gif"></section>
    <section>
      <h2>tmuxp - Tony Narlock</h2>
    </section>
    <section data-background="./tmumporot x.gif"></section>
    <section>
      <h2>Further Reading:</h2>
      <ul>
        <li><a href="http://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con">Terminals, shells, tty, console</a></li>
        <li><a href="http://www.linusakesson.net/programming/tty/">The TTY Demystified</a></li>
        <li><a href="http://invisible-island.net/xterm/ctlseqs/ctlseqs.html">xterm sequences</a></li>
      </ul>
      <h2>Fun Videos</h2>
      <ul>
        <li>http://utcc.utoronto.ca/~cks/space/blog/unix/TypingEOFEffects</li>
        <li><a href="https://www.youtube.com/watch?v=qv5b1Xowxdk&feature=youtu.be&t=372">Loading 4K BASIC with a Teletype</a></li>
        <li><a href="https://www.youtube.com/watch?v=DFMQ1qT_RFM">Teletype Model 35ASR</a></li>
        <li><a href="https://www.youtube.com/watch?v=HcMHam54EOI">How The Teleprinter Works- 1940</a></li>
      </ul>
    </section>
    <section>
      <h2>Thanks for listening!</h2>
      <p>I'll announce on Twitter (@ballingt) when a blog post is up</p>
      <p>I'll be at both days of sprints, probably working on bpython and Curtsies</p>
    </section>
    <section data-background="bpython-curtsies-demo-large.gif"></section>
  </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
controls: true,
progress: true,
history: true,
center: true,

transition: 'none', // none/fade/slide/convex/concave/zoom
backgroundTransition: 'none', // none/fade/slide/convex/concave/zoom

// Optional reveal.js plugins
dependencies: [
{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
{ src: 'plugin/zoom-js/zoom.js', async: true },
{ src: 'plugin/notes/notes.js', async: true }
]
});

</script>

</body>
</html>
