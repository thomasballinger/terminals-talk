<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">

<title>Terminal Whispering</title>

<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
<meta name="author" content="Hakim El Hattab">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="css/reveal.css">
<link rel="stylesheet" href="css/theme/black.css" id="theme">

<!-- Code syntax highlighting -->
<link rel="stylesheet" href="lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

  <!-- Any section element inside of this container is displayed as a slide -->
  <div class="slides">
    <section>
      <h1>Terminal Whispering</h1>
      <p>Do more than print text with your terminal</p>
      <p>
      <small><a href="http://ballingt.com">Thomas Ballinger</a> | <a href="http://twitter.com/ballingt">@ballingt</a> | <a href="mailto:me@ballingt.com">me@ballingt.com</a> | <a href="https://www.recurse.com">tom@recurse.com</a></small>
      </p>
    </section>
    <section>
      <section>
      <h2>Terminals are cool</h2>
      <p>wget</p>
      <p>less</p>
      <p>top</p>
      <p>bpython</p>
      <p>pudb</p>
      <p>vim</p>
      <p>telnet towel.blinkenlights.nl</p>
        <aside class="notes">
          Many of us use terminals daily - 
        </aside>
      </section>
      <section data-background="tig.gif"></section>
      <section data-background="pudb.gif"></section>
      <section data-background="bpython-curtsies-demo-large.gif"></section>
    </section>

    <section>
      <section>
        <h2>What are terminals?</h2>
        <aside class="notes">
          Well, we're usually talking about terminal emulators
        </aside>
      </section>
      <section data-background="wordcloud.png">
        <aside class="notes">
          Don't worry, you're not at the wrong talk
          that word has lots of meanings though
        </aside>
      </section>
      <section data-background="single-terminal.png">
        <aside class="notes">
          When I say "terminal", I'm usually talking about a terminal emulator.
          I'm also lumping in things my kernal does in tandem with the terminal emulator.
          I mean the thing that an application thinks it's talking to.

          You can see the little mac GUI stuff in this picture - 
          I should mention that this talk is currently scoped just to unix terminals.
          Some of it may apply to the Windows console.

          An interactive command line program is going to assume when it writes
          bytes on standard out, they're going to end up at a terminal.
          Assume that reads on stdin are coming from a terminal.

          What is it that we're emulating?

        </aside>
      </section>
      <!--TODO: add examples from more operating systems - include putty!-->
      <section data-background="terminals.png">
        <aside class="notes">
          These - video terminals. Applications would be written
          anticipating that the human user would be sitting in front
          of one of these. But video terminals were emulating something
          else originally...
        </aside>
        <!--TODO: Remove off-topic pictures -->
      </section>
      <section data-background="teletypes.png">
        <aside class="notes">
          Teleprinters or teletypewriters, or one of the brands...

          Check out a youtube video of this stuff, they're
          mechanical marvels!
          These had been being used to send telegraphs for a long time
          (great 1940 video about how they work: https://www.youtube.com/watch?v=HcMHam54EOI)
        </aside>
      </section>
      <section data-background="teletypead2.png">
        <aside class="notes">
          Let's look at this great ad for a teletype machine.
        </aside>
      </section>
    </section>

    <section>
      <section>
        <pre>
fingers pressing keys---+   +-signal-over-metal-wire---> application
                        |   |                              |
                        |   |                              |
                        V   |                              |
    paper  <--ink----teletypewriter <--probably copper?----+
        </pre>
        <aside class="notes">
          The way teletypes worked lays the foundation for the way
          terminal emulators still work today.
        </aside>
      </section>
      <section>
        <pre>
fingers pressing keys---+
                        |
                        |
                        V
    paper  <--ink----teletypewriter
        </pre>
        <aside class="notes">
          A user types at an electronic typewriter which both puts ink to
          paper immediately...
        </aside>
      </section>
      <section>
        <pre>
fingers pressing keys---+   +-signal-over-metal-wire---> application
                        |   |
                        |   |
                        V   |
    paper  <--ink----teletypewriter
       </pre>
        <aside class="notes">
          and also sends some kind of signal down a wire.
          This could be only 5 bits for telegraph stuff
          
          
          , then ANSI made it 7 -
          who knows if you need a whole byte or not? Write a device driver
          that deals with whatever telegraph stuff was already in place
        </aside>
      </section>
      <section>
        <pre>
fingers pressing keys---+   +-signal-over-metal-wire---> application
                        |   |                              |
                        |   |                              |
                        V   |                              |
    paper  <--ink----teletypewriter <--probably copper?----+
       </pre>
        <aside class="notes">
          The application sends back data that gets printed by the teletype.

          Once again, very interesting on YouTube videos! I'll link at the end.

          Next, let's look at the modernized version of our diagram...
        </aside>
      </section>
      <section>
        <pre>
 keyboard--keypresses---+   +--read() returns bytes----> application
                        |   |                              |
                        |   |                              |
                        V   |                              |
    screen <--display--terminal <--write(bytes)------------+
                      (+ kernel)
        </pre>
        <aside class="notes">
          "terminal" here means our terminal emulator.
          `read` and `write` are system calls - we call them
          on special files like standard in and out.

          The application makes both of these calls.
        </aside>
      </section>
      <section>
        <pre>
 keyboard--keypresses---+   +--------input()-----------> application
                        |   |                              |
                        |   |                              |
                        V   |                              |
    screen <--display--terminal <-----print()--------------+
        </pre>
        <aside class="notes">
          Or as we call them in python, input and print.

          This is a simplified diagram - there's probably some stuff between the application and the signals.
          If it's so simplified, why do we need this intermediate step? Because keypresses also cause things
          to be displayed, and messages that are sent might result in other things than text being displayed.

          We'll look at input in a moment, but first let's look at what we can write to our terminal.
        </aside>
      </section>
    </section>
    <section>
      <section>
        <p>What bytes can we write and what happens?</p>
        <pre>
                                                 application
                                                      |
                                                      |
                                                      |
        screen <--display--terminal <--write(bytes)---+
        </pre>
      </section>
      <section>
        <h2>What bytes can we send?</h2>
        <ul>
          <li> ASCII bytes
          <ul class="fragment">
            <li> <code>sys.stdout.buffer.write(b'some bytes')</code> </li>
            <li class="fragment"> control characters (<code>[chr(x) for x in range(32)]</code> or <code>'\a\n\r\v\b\f\t'</code>) </li>
          </ul>
          </li>
        </ul>
      </section>
      <section data-background="ascii.png">
        <aside class="notes">
          ASCII is a mapping of signals to meanings, when the signals getting sent on those metal wires
          were sort of standardized in the 60's.

          Even though you only need 5 bits to get all the letters, now we'll splurge and use 7 bits(!)
          Once you start using 8-bit bytes to store a character each, we have an extra one - but ASCII was before this.
        </aside>
      </section>
      <section data-background="ascii-normal.png"></section>
      <section data-background="ascii-control.png">
        <aside class="notes">
        Control characters let us do special things... (demo!)
        </aside>
      </section>
      <section data-background="wget.gif"> </section>
      <section>
        <pre><code>from __future__ import division
import time
import sys

def report_progress(ratio, width=50):
    complete = int(ratio * width)
    sys.stderr.write('\r|{}{}|'.format('='*complete,
                                       '-'*(width - complete)))
    sys.stderr.flush()

for i in range(101):
    report_progress(i/100, 50)
    time.sleep(.01) </code></pre>
      </section>
      <section>
        <h2>What bytes can we send?</h2>
        <ul>
          <li> ASCII bytes
          <ul>
            <li> <code>sys.stdout.buffer.write(b'some bytes')</code> </li>
            <li> control characters (<code>[chr(x) for x in range(32)]</code> or <code>'\a\n\v\b\f\t'</code>) </li>
          </ul>
          <li class="fragment"> if terminal using an encoding, several bytes to make a character:
          <ul>
            <li class="fragment"> <code>sys.stdout.buffer.write(b'\xe2\x88\x82')</code> </li>
            <li class="fragment"> <code>sys.stdout.write(u'∂')</code> (via <code>.encoding</code>) </li>
          </ul></li>
          <li class="fragment"> ANSI escape sequences (<code>'\x1b[31m'</code>) </li>
        </ul>
        <aside class="notes">
          This stuff doesn't make sense with typewriters anymore.

          VT52 allowed cursor placement. In widespread use by the 80s.
          The VT100 was a big one. Applications would send these things to the terminal,
          so you wanted them to work.
        </aside>
      </section>
      <section data-background="terminals.png"></section>
      <section>
        <h2>ANSI escape sequences</h2>
        <table>
          <thead>
            <tr>
              <th>Sequence</th>
              <th>Meaning</th>
            </tr>
          </thead>
          <tbody>
          <tr>
            <td><code>\x1b[23A</code></td>
            <td>move cursor 23 rows up</td>
          </tr>
          <tr>
            <td><code>\x1b[2J</code></td>
            <td>clear entire screen</td>
          </tr>
          <tr>
            <td><code>\x1b[ ?25l</code></td>
            <td>hide the cursor</td>
          </tr>
          <tr>
            <td><code>\x1b[1m</code></td>
            <td>start writing in bold</td>
          </tr>
          <tr>
            <td><code>\x1b[31m</code></td>
            <td>start writing in red</td>
          </tr>
          </tbody>
        </table>

        <p>See <a href="http://en.wikipedia.org/wiki/ANSI_escape_code">Wikipedia entry on ANSI escape sequences</a> for more.</p>

        <aside class="notes">
          This implies our terminals are a little smarter - they have state!
          The terminal is put into "red" mode, and everything after that is red until it stops being red. There was state in the typewriters, but it was
          just "how far to the right is the curtsor."
        </aside>
      </section>
      <section>
        <script type="text/javascript" src="https://asciinema.org/a/14808.js" id="asciicast-14808" data-size="medium" async></script>
        <aside class="notes">
          Prelude to the browser wars! Video terminals add features, and have to emulate all the other features.
          BBS and MUD systems are the website analogues there.
        </aside>
      </section>
      <section>
        <h2>Compatibility Concerns</h2>
        <p> having escape sequences in your code isn't great idea </p>
        <p> Curses, ncurses, terminfo, termcap</p>
        <p><code>tput</code></p>
        <aside class="notes">
          BUT the ANSI escape sequences are mostly honored, but that's like being optimistic and using cool new JavaScript features even though they won't work on
          all browsers. And there are other commands not in the ASCII spec that are like using new ecma script stuff. For browsers, there's a thing called jquery
          which acts as a compatibility layer between web application code and browsers. 

          Terminfo is what we use for this - it's a database of terminals, and it examines the terminal's $TERM value. In the shell you'd use tput...
        </aside>
      </section>
      <section>
        <pre><code class="bash">
          tput clear
          echo "hello world"
          echo "Input please"
          tput cuu1
          tput cuu1
          tput cuf1
          tput cuf1
          tput cuf1
          tput cuf1
          tput cuf1
          tput cuf1
          tput el
          read akey
          tput clear
          echo Thanks
        </code></pre>
        <small>code sample from http://aplawrence.com/Basics/tput_stty.html</small>
      </section>
      <section>
        <ul>
          <li>Blessings - Eric Rose - see "Designing Poetic APIs" from last year</li>
        </ul>
        <pre><code>
from blessings import Terminal

t = Terminal()

print t.bold('Hi there!')
print t.bold_red_on_bright_green('It hurts my eyes!')

with t.location(0, t.height - 1):
    print 'This is at the bottom.'
        </code></pre>
        <aside class="notes">
        BUT I wouldn't use ncurses (import curses) in the Python stdlib either. Good as a compatibility layer, bad as an api.
        Eric Rose gave a great talk last year called "designing poetic apis" in which he uses his Blessings library as an example.

        There are at least two reasons to use jquery: you like the abstractions it gives you, and compatibility.
        In my experience, the compatibility is less important because the ASCII standard mostly took hold.
        But it's still nicer than hardcoding, and it's definitely. Now that you know these are just bytes you're
        still responsible for writing to the terminal, you're prepared to using Blessings!
        </aside>
      </section>
    </section>

    <section>
      <section>
        <p>What happens when the user types at the keyboard</p>
        <pre>
          keyboard--keypresses---+   +--read(bytes)---> application
                                 |   |
                                 |   |
                                 V   |
             screen <--display--TERMINAL (+ the kernel)
        </pre>
      </section>
      <section>
        <p>What happens when the user types at the keyboard</p>
        <ul>
          <li class="fragment">buffering, line editing discipline</li>
          <ul>
            <li class="fragment">data not passed to application until the user hits return</li>
            <li class="fragment">backspace, delete word, reprint line, delete line - not much else</li>
            <li class="fragment">(try cat to see this behavior)</li>
          </ul>
          <li class="fragment">echoing back characters</li>
        </ul>
        <aside class="notes">
          Terminal (or something on the wire between the terminal
          and the the application) doesn't give the bytes until
          the user hits enter.

          line editing discipline - before the application gets
          the bytes, you can use delete! And delete word!

          Echoing back characters - the terminal is doing this,
          just like a typewriter! But it doesn't have to.
          Modified diagram! We have knobs on the terminal
          emulator, and we adjust them with 
        </aside>
      </section>
      <section>
        <pre>
keyboard--keypresses---+   +--------input()----------> application
                       |   |                             |   |
                       |   |                             |   |
                       V   |                             |   |
   screen <--display--terminal <-----print()-------------+   |
                        ⚒                                    |
                        +--------<--app can get and set-->---+
        </pre>
        <aside class="notes">
          We change this stuff with ioctrl, cbreak, raw, etc

          class of system calls for messings with this stuff

        </aside>
      </section>
      <section>
        <ul>
          <li> termios </li>
          <li> ioctrl </li>
          <li> fcntl </li>
          <li> cbreak </li>
          <li> raw </li>
        </ul>
        <aside class="notes">
          We change this stuff with ioctrl, cbreak, raw, etc

          class of system calls for messings with this stuff

          I'll show a quick example that your eyes are welcome to glaze over for - because afterwards
          I'll tell you to use a library for it.
        </aside>
      </section>
      <section>
        Turning off echo in Python
        <pre> <code class="python">
          >>> import getpass
          >>> getpass.getpass()
          Password:
          'secret'
        </code> </pre>
      </section>
      <section>
        Turning off echo, using stty
        <pre><code>
          $ stty -echo
          $ echo "echo is turned off"
          $ stty echo
        </code></pre>
      </section>
      <section>
        Turning off echo in Python
        <pre> <code>
def getpass(prompt="Password: "):
    import termios, sys
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    new = termios.tcgetattr(fd)
    new[3] = new[3] & ~termios.ECHO          # lflags
    try:
        termios.tcsetattr(fd, termios.TCSADRAIN, new)
        passwd = raw_input(prompt)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return passwd
        </code></pre>
        from https://docs.python.org/2/library/termios.html
      </section>
      <section>
        <pre><code>
import sys, termios

class NoEcho:
    def __init__(self, in_stream):
        self.fd = in_stream.fileno()

    def __enter__(self):
        self.orig = termios.tcgetattr(self.fd)
        new = termios.tcgetattr(self.fd)
        new[3] = new[3] & ~termios.ECHO
        termios.tcsetattr(fd, termios.TCSADRAIN, new)

    def __exit__(self, exc_type, exc_value, traceback):
        termios.tcsetattr(self.fd), termios.TCSADRAIN, self.orig)
        </code></pre>
      </section>
      <section>
        <pre><code>
with NoEcho(sys.stdin):
    h = sys.stdin.readline()
    print(h)

        </code></pre>
        <aside class="notes">
        This is an excellent fit for a context manger, because this is state external to our
        Python program - if we crash, we don't want the terminal to be unsuable by the user.

        (tip: if it ever is, try "reset")
        </aside>
      </section>
      <section>
        Use blessings instead.
      </section>
      <section>
        <ul>
          <li>turn off echo</li>
          <li>nonblocking input</li>
          <li>current terminal size</li>
          <li>send keys immediately (don't wait for enter)</li>
        </ul>
        <aside class="notes">
          Unclear which of these are part of blessings right now, since Blessed was just merged with it.
        </aside>
      </section>
      <section>
        <p>What happens when the user types at the keyboard</p>
        <ul>
          <li>buffering, line editing discipline</li>
          <li><ul>
            <li>data not passed to application until the user hits return</li>
            'secret'  <li>backspace, delete word, reprint line, delete line - not much else</li>
            <li>to see this, try cat (it doesn't use readline)</li>
          </ul></li>
          <li> echoing back characters</li>
          <li class="fragment">bytes sent without being typed (cursor query)</li>
        </ul>
      </section>
      <section>
        <p> You probably don't need this </p>
        <p> My library Curtsies implements it </p>
        <aside class="notes">
          There are ways to save the cursor postion - BUT if you do, 
        </aside>
      </section>
      <section>
        <pre>
 keyboard--keypresses---+   +--------input()-----------> application
                        |   |                              |
                        |   |                              |
                        V   |                              |
    screen <--display--terminal <-----print()--------------+
        </pre>
        <code>>>> print("\x1b[6n")</code>
        <aside class="notes">
        Particularly interesting because writing bytes doesn't do anything
        to the display, we just get some informative bytes back the next time
        we call read!

        Important to do this in unbuffered mode, otherwise they'll just show
        up on the terminal line as though the user typed them.

        Try it!
        </aside>

      </section>
    </section>
    <section>
      <section>
        <p>How can the terminal notify the application?</p>
        <pre>
                         +----------signals--------------+
                         |                               V
keyboard--keypresses---+ | +--------input()----------> application
                       | | |                             |   |
                       | | |                             |   |
                       V | |                             |   |
   screen <--display--terminal <-----print()-------------+   |
                        ⚒                                    |
                        +--------<--app can get and set-->---+
        </pre>
        <aside class="notes">
          The terminal can push things: window changes, suspend, etc.
          The behavior of these is set with our knobs.
        </aside>
      </section>
      <section>
        <p>What happens when the user types at the keyboard</p>
        <ul>
          <li class="fragment">signals sent to application</li>
        </ul>
      </section>
    </section>
    <section>
      <h2>Tools</h2>
      <ul>
        <li>Blessings - Eric Rose - see "Designing Poetic APIs" from last year</li>
        <li>x84, Blessed (soon included in blessings) - Jeff Quast</li>
        <li>Urwid - Ian Ward - a few examples</li>
        <li>Click - Armin Ronacher</li>
        <li>Clint - Kenneth Reitz</li>
        <li>Python Prompt Toolkit - Jonathan Slenders</li>
        <li>Curtsies - Tom Ballinger</li>
      </ul>
        <aside class="notes">
          Well, we're usually talking about terminal emulators
        </aside>
    </section>
    <!--TODO: 
    <section>
      Relevant environmental variables. One way python guesses the encoding
      When you're in bash, $COLUMNS and $ROWS are available
      that struct in memory that has window size in it
      window size changed signal
    </section>
    add examples from more operating systems - include putty!-->
    <section>
      Other topics:
      scrollback buffer works, alternate screen, scroll regions, 
    </section>
    <section>
      <h2>Random cool stuff</h2>
      <p>termcast</p>
      <p>telnet towel.blinkenlights.nl</p>
    </section>
    <section>
      <h2>Further Reading:</h2>
      <ul>
        <li><a href="http://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con">Terminals, shells, tty, console</a></li>
        <li><a href="http://www.linusakesson.net/programming/tty/">The TTY Demystified</a></li>
      </ul>
      <h2>Fun Videos</h2>
      <ul>
        <li>http://utcc.utoronto.ca/~cks/space/blog/unix/TypingEOFEffects</li>
        <li><a href="https://www.youtube.com/watch?v=qv5b1Xowxdk&feature=youtu.be&t=372">Loading 4K BASIC with a Teletype</a></li>
        <li><a href="https://www.youtube.com/watch?v=DFMQ1qT_RFM">Teletype Model 35ASR</a></li>
        <li><a href="https://www.youtube.com/watch?v=HcMHam54EOI">How The Teleprinter Works- 1940</a></li>
      </ul>
      <h2>Image credits</h2>
      <ul>
        <li>Wordcloud credit: https://www.jasondavies.com/wordcloud</li>
      </ul>
    </section>
  </div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
controls: true,
progress: true,
history: true,
center: true,

transition: 'slide', // none/fade/slide/convex/concave/zoom
backgroundTransition: 'none', // none/fade/slide/convex/concave/zoom

// Optional reveal.js plugins
dependencies: [
{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
{ src: 'plugin/zoom-js/zoom.js', async: true },
{ src: 'plugin/notes/notes.js', async: true }
]
});

</script>

</body>
</html>
